{"version":3,"sources":["theme.tsx","api/AppApi.tsx","state/weather-state.tsx","App.tsx","serviceWorker.ts","locale/i18n.tsx","locale/en.tsx","locale/de.tsx","index.tsx"],"names":["theme","colorPrimary","colorSecondary","textPrimary","textSecondary","background","AppApi","WeatherstackAPIKey","this","process","fetch","response","json","data","cities","records","map","r","name","fields","accentcity","country","region","sort","a","b","localeCompare","console","log","cityName","url","weather","city","location","current","observation_time","temperature","weather_code","weather_icons","weather_descriptions","wind_speed","wind_degree","wind_dir","pressure","precip","humidity","cloudcover","feelslike","uv_index","visibility","is_day","updated_at","Date","lat","lon","query","WeatherState","types","model","string","number","array","boolean","actions","self","CityState","id","identifier","currentWeather","maybeNull","views","isUpdated","now","getTime","isFavorite","getParentOfType","AppState","favoriteCities","findIndex","c","setCurrentWeather","create","topCities","reference","findCity","get","addToTopCity","index","push","splice","removeFromTopCity","setTopCities","clear","forEach","cityRef","put","addToFavorite","removeFromFavorite","updateCurrentWeather","api","getEnv","Promise","all","values","fetchWeatherForCity","addSearchedCityWeather","init","length","fetchTopCities","fetchCity","storeContext","React","createContext","AppStateProvider","children","store","useLocalStore","createStore","Provider","value","useAppState","useContext","Error","appStore","localStorage","getItem","injection","JSON","parse","err","error","onSnapshot","snapshot","setItem","stringify","NoMatch","lazy","Home","CityWeather","useStyles","createUseStyles","html","backgroundColor","body","margin","fontFamily","App","useTheme","path","DefaultLoadingIndicator","Boolean","window","hostname","match","resources","en","translation","de","i18n","use","initReactI18next","lng","interpolation","escapeValue","ReactDOM","render","StrictMode","fallback","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.6b059a78.chunk.js","sourcesContent":["export { createUseStyles, useTheme } from 'react-jss';\n\nexport const theme = {\n  colorPrimary: \"green\",\n  colorSecondary: \"red\",\n  textPrimary: \"#ccc\",\n  textSecondary: \"#eee\",\n  background: '#eee',\n}\n\nexport type Theme = typeof theme;\n\n","\nexport interface IWeatherData {\n  city: ICity,\n  current: {\n    observation_time: string,\n    temperature: number,\n    weather_code: number,\n    weather_icons: string[],\n    weather_descriptions: string[],\n    wind_speed: number,\n    wind_degree: number,\n    wind_dir: string,\n    pressure: number,\n    precip: number,\n    humidity: number,\n    cloudcover: number,\n    feelslike: number,\n    uv_index: number,\n    visibility: number,\n    is_day: boolean,\n    updated_at: Date,\n  }\n}\n\nexport interface ICity {\n  name: string,\n  country: string,\n  region: string,\n}\n\nexport class AppApi {\n  private WeatherstackAPIKey: string;\n\n  constructor(){\n    // Setting api key in front-end is a bad practice and not secure,\n    // but as the requirement is to avoid having back-end there is no other way \n    this.WeatherstackAPIKey = process.env.REACT_APP_WEATHERSTACK_API_KEY || '';\n  }\n\n  async fetchTopCities(): Promise<ICity[] | undefined> {\n    const url = `https://public.opendatasoft.com/api/records/1.0/search/?dataset=worldcitiespop&q=&rows=15&sort=population&facet=country`;\n    try{\n      const response = await fetch(url);\n      const data = await response.json() as { records: any[] };\n      const cities = data?.records?.map( (r: any) => ({\n        name: (r?.fields?.accentcity || r?.fields?.name) as string,\n        country: r?.fields?.country as string,\n        region: r?.fields?.region as string,\n      })).sort( (a, b) => a.name.localeCompare(b.name));\n      return cities;\n    }catch(err){\n      console.log(err);\n    }\n  }\n\n  async fetchWeatherForCity(cityName: string): Promise<IWeatherData | undefined> {\n    // using http is not secure, but the free plan of the api does not support it\n    const url = `http://api.weatherstack.com/current?access_key=${this.WeatherstackAPIKey}&query=${cityName}`;\n    // docs under https://weatherstack.com/documentation#query_parameter\n    try{\n      const response = await fetch(url);\n      const data = await response.json();\n      const weather = {\n        city: {\n          name: data.location.name,\n          country: data.location.country,\n          region: data.location.region,\n        },\n        current: {\n          observation_time: data.current.observation_time,\n          temperature: data.current.temperature,\n          weather_code: data.current.weather_code,\n          weather_icons: data.current.weather_icons,\n          weather_descriptions: data.current.weather_descriptions,\n          wind_speed: data.current.wind_speed,\n          wind_degree: data.current.wind_degree,\n          wind_dir: data.current.wind_dir,\n          pressure: data.current.pressure,\n          precip: data.current.precip,\n          humidity: data.current.humidity,\n          cloudcover: data.current.cloudcover,\n          feelslike: data.current.feelslike,\n          uv_index: data.current.uv_index,\n          visibility: data.current.visibility,\n          is_day: data.current.is_day === \"yes\",\n          updated_at: new Date(),\n        }\n      };\n      return weather;\n    }catch(err){\n      console.log(err);\n    }\n  }\n\n  async fetchWeatherForLocation(lat: number, lon: number): Promise<IWeatherData | undefined> {\n    // using http is not secure, but the free plan of the api does not support it\n    const url = `http://api.weatherstack.com/current?access_key=${this.WeatherstackAPIKey}&query=${lat},${lon}`;\n    // docs under https://weatherstack.com/documentation#query_parameter\n    return;\n  }\n\n  async fetchWeatherForMyIP(): Promise<IWeatherData | undefined> {\n    // using http is not secure, but the free plan of the api does not support it\n    const url = `http://api.weatherstack.com/current?access_key=${this.WeatherstackAPIKey}&query=fetch:ip`;\n    // docs under https://weatherstack.com/documentation#query_parameter\n    return;\n  }\n\n  async fetchLookup(query: string): Promise<ICity | undefined> {\n    // using http is not secure, but the free plan of the api does not support it\n    const url = `http://api.weatherstack.com/autocomplete?access_key=${this.WeatherstackAPIKey}&query=${query}`;\n    // docs under https://weatherstack.com/documentation#query_parameter\n    return;\n  }\n\n}","import React from 'react';\nimport { useLocalStore } from 'mobx-react-lite';\nimport { types, Instance, SnapshotIn, onSnapshot, getParentOfType, getEnv } from \"mobx-state-tree\";\nimport { AppApi, ICity, IWeatherData } from '../api/AppApi';\n\nconst WeatherDataTTL = 10 * 60 * 1000;\n\nexport const WeatherState = types\n  .model(\"WeatherState\", {\n    observation_time: types.string,\n    temperature: types.number,\n    weather_code: types.number,\n    weather_icons: types.array(types.string),\n    weather_descriptions: types.array(types.string),\n    wind_speed: types.number,\n    wind_degree: types.number,\n    wind_dir: types.string,\n    pressure: types.number,\n    precip: types.number,\n    humidity: types.number,\n    cloudcover: types.number,\n    feelslike: types.number,\n    uv_index: types.number,\n    visibility: types.number,\n    is_day: types.boolean,\n    updated_at: types.Date,\n  })\n  .actions(self => {\n    return {\n    }\n  });\n\nexport const CityState = types\n  .model(\"CityState\", {\n    id: types.identifier,\n    name: types.string,\n    country: types.string,\n    region: types.string,\n    currentWeather: types.maybeNull(WeatherState),\n  })\n  .views(self => {\n    return {\n      isUpdated(now: Date){\n        return now.getTime() - (self.currentWeather?.updated_at.getTime() || 0) < WeatherDataTTL;\n      },\n      isFavorite(): boolean{\n        const parent = getParentOfType(self, AppState);\n        const index = parent.favoriteCities.findIndex( c => c === self);\n        return index !== -1;\n      },\n    }\n  })\n  .actions(self => {\n    return {\n      setCurrentWeather(weather: IWeatherData){\n        self.name = weather.city.name;\n        self.country = weather.city.country;\n        self.region = weather.city.region;\n        self.currentWeather = WeatherState.create(weather.current);\n      },\n    }\n  });\n\n\nexport const AppState = types\n  .model(\"AppState\", {\n    topCities: types.array(types.reference(CityState)),\n    favoriteCities: types.array(types.reference(CityState)),\n    cities: types.map(CityState),\n  })\n  .views(self => {\n    return {\n      findCity(cityName: string): ICityState | undefined{\n        const city = self.cities.get(cityName);\n        return city;\n      },\n    }\n  })\n  .actions(self => {\n    return {\n      addToTopCity(city: ICityState) {\n        const index = self.topCities.findIndex( c => c.name.localeCompare(city.name) > 0);\n        if(index === -1){\n          self.topCities.push(city);\n        }else{\n          self.topCities.splice(index, 0, city);\n        }\n      },\n      removeFromTopCity(city: ICityState) {\n        const index = self.topCities.findIndex( c => c === city);\n        if(index !== -1){\n          self.topCities.splice(index, 1);\n        }\n      },\n    }\n  })\n  .actions(self => {\n    return {\n      setTopCities(cities: ICity[]) {\n        self.topCities.clear();\n        cities.forEach( city => {\n          const cityRef = self.cities.put(CityState.create({\n            id: city.name,\n            name: city.name,\n            country: city.country,\n            region: city.region,\n          }));\n          if(!cityRef.isFavorite()){\n            self.topCities.push(cityRef);\n          }\n        });\n      },\n      addToFavorite(city: ICityState) {\n        const index = self.favoriteCities.findIndex( c => c.name.localeCompare(city.name) > 0);\n        if(index === -1){\n          self.favoriteCities.push(city);\n        }else{\n          self.favoriteCities.splice(index, 0, city);\n        }\n        self.removeFromTopCity(city);\n      },\n      removeFromFavorite(city: ICityState) {\n        const index = self.favoriteCities.findIndex( c => c === city);\n        if(index !== -1){\n          self.favoriteCities.splice(index, 1);\n          self.addToTopCity(city);\n        }\n      },\n      async updateCurrentWeather(){\n        const api = getEnv<EnvType>(self).api;\n        const now = new Date();\n        await Promise.all([...self.cities.values()].map( async (city) => {\n          if(city.isUpdated(now)){\n            return;\n          }\n          const weather = await api.fetchWeatherForCity(city.name);\n          if(weather){\n            city.setCurrentWeather(weather);\n          }\n        }));\n      },\n      addSearchedCityWeather(weather: IWeatherData){\n        self.cities.put(CityState.create({\n          id: weather.city.name,\n          name: weather.city.name,\n          country: weather.city.country,\n          region: weather.city.region,\n          currentWeather: WeatherState.create(weather.current),\n        }));\n      }\n    }\n  })\n  .actions(self => {\n    return {\n      async init() {\n        if(!self.topCities?.length){\n          const cities = await getEnv<EnvType>(self).api.fetchTopCities();\n          if(cities){\n            self.setTopCities(cities);\n          }\n        }\n        await self.updateCurrentWeather();\n      },\n      async fetchCity(cityName: string){\n        const weather = await getEnv<EnvType>(self).api.fetchWeatherForCity(cityName);\n        if(weather){\n          self.addSearchedCityWeather(weather);\n        }\n      }\n    }\n  });\n\nconst storeContext = React.createContext<IAppState | null>(null);\n\nexport const AppStateProvider: React.FunctionComponent = ({ children }) => {\n  const store = useLocalStore(createStore)\n  return <storeContext.Provider value={store}>{children}</storeContext.Provider>\n}\n\nexport const useAppState = () => {\n  const store = React.useContext(storeContext)\n  if (!store) {\n    // this is especially useful in TypeScript so you don't need to be checking for null all the time\n    throw new Error('useStore must be used within a StoreProvider.')\n  }\n  return store\n}\n\nexport type EnvType = {\n  api: AppApi,\n}\n\nexport function createStore() {\n  const appStore = localStorage.getItem('app-store');\n\n  const injection: EnvType = {\n    api: new AppApi(),\n  }\n\n  let store;\n  try {\n    store = AppState.create(appStore ? JSON.parse(appStore) : emptyStore(), injection);\n  } catch (err) {\n    console.error('could not restore, with the following error. fallback to empty store.');\n    console.error(err);\n    store = AppState.create(emptyStore(), injection);\n  }\n  // onPatch(store, patch => {\n  //   if (patch.path.startsWith('/fbd/drawingVector'))\n  //     return;\n  // });\n  onSnapshot(store, snapshot => {\n    localStorage.setItem('app-store', JSON.stringify(snapshot));\n  });\n\n  return store;\n}\n\nfunction emptyStore(): IAppStateSnapshot {\n  return {};\n}\n\nexport interface IAppState extends Instance<typeof AppState> { };\nexport interface IAppStateSnapshot extends SnapshotIn<typeof AppState> { };\nexport interface ICityState extends Instance<typeof CityState> { };\nexport interface IWeatherState extends Instance<typeof WeatherState> { };","import React, { lazy } from 'react';\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n} from \"react-router-dom\";\nimport { createUseStyles, useTheme, Theme } from './theme';\nimport { AppStateProvider } from './state/weather-state';\n\nconst NoMatch = lazy(() => import('./pages/NoMatch'));\nconst Home = lazy(() => import('./pages/Home'));\nconst CityWeather = lazy(() => import('./pages/CityWeather'));\n\nconst useStyles = createUseStyles<Theme>(theme => ({\n  '@global': {\n    html: {\n      backgroundColor: theme.background,\n    },\n    body: {\n      margin: 0,\n    },\n    'html *': {\n      fontFamily: 'Yekan Bakh',\n    },\n  },\n\n}));\n\nconst App: React.FC = () => {\n\n  const theme = useTheme();\n  useStyles({ theme });\n\n  return (\n    <AppStateProvider >\n      <Router>\n        <Switch>\n          <Route path=\"/city/:name\">\n            <CityWeather />\n          </Route>\n          <Route path=\"/\">\n            <Home />\n          </Route>\n          <Route path=\"*\">\n            <NoMatch />\n          </Route>\n        </Switch>\n      </Router>\n    </AppStateProvider>\n  );\n}\n\nexport default App;\n\nexport const DefaultLoadingIndicator = () => (\n  <div>\n    Loading...\n  </div>\n);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import i18n from \"i18next\";\nimport { initReactI18next } from \"react-i18next\";\nimport { en } from \"./en\";\nimport { de } from \"./de\";\n\n// the translations\nconst resources = {\n  en,\n  de,\n};\n\ni18n\n  .use(initReactI18next) // passes i18n down to react-i18next\n  .init({\n    resources,\n    lng: \"en\",\n\n    interpolation: {\n      escapeValue: false, // react already safes from xss\n    }\n  });\n\n  export default i18n;","export const en = {\n  translation: {\n    \"ttest\": \"TWeathr Test\"\n  }\n}","export const de = {\n  translation: {\n    \"ttest\": \"Das wetter\"\n  }\n}","import React, { Suspense } from 'react';\nimport ReactDOM from 'react-dom';\nimport App, { DefaultLoadingIndicator } from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { ThemeProvider } from 'react-jss';\nimport {theme} from './theme';\nimport './locale/i18n';\n\nReactDOM.render(\n  <React.StrictMode>\n    <ThemeProvider theme={theme}>\n      <Suspense fallback={<DefaultLoadingIndicator />}>\n        <App />\n      </Suspense>\n    </ThemeProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}