{"version":3,"sources":["containers/Lookup.tsx","utils.tsx","containers/Scaffold.tsx","../node_modules/mobx-react-lite/es/staticRendering.js","../node_modules/mobx-react-lite/es/printDebugValue.js","../node_modules/mobx-react-lite/es/reactionCleanupTracking.js","../node_modules/mobx-react-lite/es/useQueuedForceUpdate.js","../node_modules/mobx-react-lite/es/useObserver.js","../node_modules/mobx-react-lite/es/observer.js","pages/CityWeather.tsx"],"names":["useStyles","createUseStyles","theme","root","backgroundColor","colorPrimary","color","textPrimary","Lookup","useTheme","classes","state","useAppState","handleSearch","func","timeout","timer","args","clearTimeout","setTimeout","debounce","query","setLookup","className","type","defaultValue","lookup","onChange","event","target","value","LookupResultList","observer","results","lookupResult","map","result","key","name","region","country","WeatherApiLinkBack","Scaffold","children","href","title","globalIsUsingStaticRendering","isUsingStaticRendering","printDebugValue","v","getDependencyTree","reactionCleanupHandle","CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS","uncommittedReactionRefs","Set","ensureCleanupTimerRunning","undefined","cleanUncommittedReactions","now","Date","forEach","ref","tracking","current","cleanAt","reaction","dispose","delete","size","insideRender","forceUpdateQueue","EMPTY_OBJECT","observerComponentNameFor","baseComponentName","useObserver","fn","options","queuedForceUpdate","forceUpdate","push","useQueuedForceUpdate","useForceUpdate","reactionTrackingRef","React","useRef","newReaction_1","Reaction","trackingData_1","mounted","createTrackingData","add","useDebugValue","useEffect","reactionRef","Infinity","callback","queue_1","length","useLayoutEffect","x","useQueuedForceUpdateBlock","rendering","exception","track","e","__assign","Object","assign","t","s","i","n","arguments","p","prototype","hasOwnProperty","call","apply","this","baseComponent","memoComponent","base","realOptions","forwardRef","displayName","wrappedComponent","props","memo","keys","hoistBlackList","defineProperty","getOwnPropertyDescriptor","$$typeof","render","compare","CityWeather","useParams","city","findCity","fetchCity","favorite","isFavorite","currentWeather","temp_c","onClick","addToFavorite","removeFromFavorite","addToTopCity"],"mappings":"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","file":"static/js/4.38c0a221.chunk.js","sourcesContent":["import React from 'react';\nimport { createUseStyles, useTheme, Theme } from '../theme';\nimport { useAppState } from '../state/weather-state';\nimport { observer } from 'mobx-react-lite';\nimport { debounce } from '../utils';\n\nconst useStyles = createUseStyles<Theme>(theme => ({\n  root: {\n    backgroundColor: theme.colorPrimary,\n    color: theme.textPrimary,\n  },\n}));\n\nconst Lookup: React.FC = () => {\n  const theme = useTheme();\n  const classes = useStyles({theme});\n\n  const state = useAppState();\n\n  const handleSearch = debounce((query: string) => {\n    state.setLookup(query);\n  }, 300);\n\n  return (\n    <div className={classes.root}>\n      <input type=\"text\" defaultValue={state.lookup} onChange={(event) => handleSearch(event.target.value)}/>\n      <LookupResultList/>\n    </div>\n  );\n};\n\nexport default Lookup;\n\nconst LookupResultList: React.FC = observer(() => {\n  const state = useAppState();\n\n  const results = state.lookupResult;\n\n  return (\n    <div>\n      {results.map( result => (\n        <div key={result.name}>{result.name} / {result.region} / {result.country}</div>\n      ))}\n    </div>\n  )\n});","export function debounce<Params extends any[]>(\n  func: (...args: Params) => (void | Promise<void>),\n  timeout: number,\n): (...args: Params) => void {\n  let timer: NodeJS.Timeout;\n  return (...args: Params) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      return func(...args);\n    }, timeout);\n  }\n}","import React from 'react';\nimport { createUseStyles, useTheme, Theme } from '../theme';\nimport Lookup from './Lookup';\n\nconst useStyles = createUseStyles<Theme>(theme => ({\n  root: {\n    backgroundColor: theme.colorPrimary,\n    color: theme.textPrimary,\n  },\n}));\n\nconst Scaffold: React.FC = ({children}) => {\n  const theme = useTheme();\n  const classes = useStyles({theme});\n\n  return (\n    <div className={classes.root}>\n      <Lookup/>\n      {children}\n      <WeatherApiLinkBack/>\n    </div>\n  );\n};\n\nexport default Scaffold;\n\n\nconst WeatherApiLinkBack: React.FC = () => {\n  return (\n    <div>\n      Powered by <a href=\"https://www.weatherapi.com/\" title=\"Free Weather API\">WeatherAPI.com</a>\n    </div>\n  )\n};","var globalIsUsingStaticRendering = false;\nexport function useStaticRendering(enable) {\n    globalIsUsingStaticRendering = enable;\n}\nexport function isUsingStaticRendering() {\n    return globalIsUsingStaticRendering;\n}\n","import { getDependencyTree } from \"mobx\";\nexport function printDebugValue(v) {\n    return getDependencyTree(v);\n}\n","export function createTrackingData(reaction) {\n    var trackingData = {\n        cleanAt: Date.now() + CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS,\n        reaction: reaction\n    };\n    return trackingData;\n}\n/**\n * The minimum time before we'll clean up a Reaction created in a render\n * for a component that hasn't managed to run its effects. This needs to\n * be big enough to ensure that a component won't turn up and have its\n * effects run without being re-rendered.\n */\nexport var CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS = 10000;\n/**\n * The frequency with which we'll check for leaked reactions.\n */\nexport var CLEANUP_TIMER_LOOP_MILLIS = 10000;\n/**\n * Reactions created by components that have yet to be fully mounted.\n */\nvar uncommittedReactionRefs = new Set();\n/**\n * Latest 'uncommitted reactions' cleanup timer handle.\n */\nvar reactionCleanupHandle;\nfunction ensureCleanupTimerRunning() {\n    if (reactionCleanupHandle === undefined) {\n        reactionCleanupHandle = setTimeout(cleanUncommittedReactions, CLEANUP_TIMER_LOOP_MILLIS);\n    }\n}\nexport function scheduleCleanupOfReactionIfLeaked(ref) {\n    uncommittedReactionRefs.add(ref);\n    ensureCleanupTimerRunning();\n}\nexport function recordReactionAsCommitted(reactionRef) {\n    uncommittedReactionRefs.delete(reactionRef);\n}\n/**\n * Run by the cleanup timer to dispose any outstanding reactions\n */\nfunction cleanUncommittedReactions() {\n    reactionCleanupHandle = undefined;\n    // Loop through all the candidate leaked reactions; those older\n    // than CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS get tidied.\n    var now = Date.now();\n    uncommittedReactionRefs.forEach(function (ref) {\n        var tracking = ref.current;\n        if (tracking) {\n            if (now >= tracking.cleanAt) {\n                // It's time to tidy up this leaked reaction.\n                tracking.reaction.dispose();\n                ref.current = null;\n                uncommittedReactionRefs.delete(ref);\n            }\n        }\n    });\n    if (uncommittedReactionRefs.size > 0) {\n        // We've just finished a round of cleanups but there are still\n        // some leak candidates outstanding.\n        ensureCleanupTimerRunning();\n    }\n}\n/* istanbul ignore next */\n/**\n * Only to be used by test functions; do not export outside of mobx-react-lite\n */\nexport function forceCleanupTimerToRunNowForTests() {\n    // This allows us to control the execution of the cleanup timer\n    // to force it to run at awkward times in unit tests.\n    if (reactionCleanupHandle) {\n        clearTimeout(reactionCleanupHandle);\n        cleanUncommittedReactions();\n    }\n}\n/* istanbul ignore next */\nexport function resetCleanupScheduleForTests() {\n    if (reactionCleanupHandle) {\n        clearTimeout(reactionCleanupHandle);\n        reactionCleanupHandle = undefined;\n    }\n    uncommittedReactionRefs.clear();\n}\n","import React from \"react\";\nvar insideRender = false;\nvar forceUpdateQueue = [];\nexport function useQueuedForceUpdate(forceUpdate) {\n    return function () {\n        if (insideRender) {\n            forceUpdateQueue.push(forceUpdate);\n        }\n        else {\n            forceUpdate();\n        }\n    };\n}\nexport function useQueuedForceUpdateBlock(callback) {\n    // start intercepting force-update calls\n    insideRender = true;\n    forceUpdateQueue = [];\n    try {\n        var result = callback();\n        // stop intercepting force-update\n        insideRender = false;\n        // store queue or nothing if it was empty to execute useLayoutEffect only when necessary\n        var queue_1 = forceUpdateQueue.length > 0 ? forceUpdateQueue : undefined;\n        // run force-update queue in useLayoutEffect\n        React.useLayoutEffect(function () {\n            if (queue_1) {\n                queue_1.forEach(function (x) { return x(); });\n            }\n        }, [queue_1]);\n        return result;\n    }\n    finally {\n        insideRender = false;\n    }\n}\n","import { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./printDebugValue\";\nimport { createTrackingData, recordReactionAsCommitted, scheduleCleanupOfReactionIfLeaked } from \"./reactionCleanupTracking\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { useForceUpdate } from \"./utils\";\nimport { useQueuedForceUpdate, useQueuedForceUpdateBlock } from \"./useQueuedForceUpdate\";\nvar EMPTY_OBJECT = {};\nfunction observerComponentNameFor(baseComponentName) {\n    return \"observer\" + baseComponentName;\n}\nexport function useObserver(fn, baseComponentName, options) {\n    if (baseComponentName === void 0) { baseComponentName = \"observed\"; }\n    if (options === void 0) { options = EMPTY_OBJECT; }\n    if (isUsingStaticRendering()) {\n        return fn();\n    }\n    var wantedForceUpdateHook = options.useForceUpdate || useForceUpdate;\n    var forceUpdate = wantedForceUpdateHook();\n    var queuedForceUpdate = useQueuedForceUpdate(forceUpdate);\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    var reactionTrackingRef = React.useRef(null);\n    if (!reactionTrackingRef.current) {\n        // First render for this component (or first time since a previous\n        // reaction from an abandoned render was disposed).\n        var newReaction_1 = new Reaction(observerComponentNameFor(baseComponentName), function () {\n            // Observable has changed, meaning we want to re-render\n            // BUT if we're a component that hasn't yet got to the useEffect()\n            // stage, we might be a component that _started_ to render, but\n            // got dropped, and we don't want to make state changes then.\n            // (It triggers warnings in StrictMode, for a start.)\n            if (trackingData_1.mounted) {\n                // We have reached useEffect(), so we're mounted, and can trigger an update\n                queuedForceUpdate();\n            }\n            else {\n                // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n                // when (and if) useEffect() arrives.  The easiest way to do that is just to\n                // drop our current reaction and allow useEffect() to recreate it.\n                newReaction_1.dispose();\n                reactionTrackingRef.current = null;\n            }\n        });\n        var trackingData_1 = createTrackingData(newReaction_1);\n        reactionTrackingRef.current = trackingData_1;\n        scheduleCleanupOfReactionIfLeaked(reactionTrackingRef);\n    }\n    var reaction = reactionTrackingRef.current.reaction;\n    React.useDebugValue(reaction, printDebugValue);\n    React.useEffect(function () {\n        // Called on first mount only\n        recordReactionAsCommitted(reactionTrackingRef);\n        if (reactionTrackingRef.current) {\n            // Great. We've already got our reaction from our render;\n            // all we need to do is to record that it's now mounted,\n            // to allow future observable changes to trigger re-renders\n            reactionTrackingRef.current.mounted = true;\n        }\n        else {\n            // The reaction we set up in our render has been disposed.\n            // This is either due to bad timings of renderings, e.g. our\n            // component was paused for a _very_ long time, and our\n            // reaction got cleaned up, or we got a observable change\n            // between render and useEffect\n            // Re-create the reaction\n            reactionTrackingRef.current = {\n                reaction: new Reaction(observerComponentNameFor(baseComponentName), function () {\n                    // We've definitely already been mounted at this point\n                    queuedForceUpdate();\n                }),\n                cleanAt: Infinity\n            };\n            queuedForceUpdate();\n        }\n        return function () {\n            reactionTrackingRef.current.reaction.dispose();\n            reactionTrackingRef.current = null;\n        };\n    }, []);\n    // delay all force-update calls after rendering of this component\n    return useQueuedForceUpdateBlock(function () {\n        // render the original component, but have the\n        // reaction track the observables, so that rendering\n        // can be invalidated (see above) once a dependency changes\n        var rendering;\n        var exception;\n        reaction.track(function () {\n            try {\n                rendering = fn();\n            }\n            catch (e) {\n                exception = e;\n            }\n        });\n        if (exception) {\n            throw exception; // re-throw any exceptions caught during rendering\n        }\n        return rendering;\n    });\n}\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { forwardRef, memo } from \"react\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { useObserver } from \"./useObserver\";\n// n.b. base case is not used for actual typings or exported in the typing files\nexport function observer(baseComponent, options) {\n    // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\n    if (isUsingStaticRendering()) {\n        return baseComponent;\n    }\n    var realOptions = __assign({ forwardRef: false }, options);\n    var baseComponentName = baseComponent.displayName || baseComponent.name;\n    var wrappedComponent = function (props, ref) {\n        return useObserver(function () { return baseComponent(props, ref); }, baseComponentName);\n    };\n    wrappedComponent.displayName = baseComponentName;\n    // memo; we are not interested in deep updates\n    // in props; we assume that if deep objects are changed,\n    // this is in observables, which would have been tracked anyway\n    var memoComponent;\n    if (realOptions.forwardRef) {\n        // we have to use forwardRef here because:\n        // 1. it cannot go before memo, only after it\n        // 2. forwardRef converts the function into an actual component, so we can't let the baseComponent do it\n        //    since it wouldn't be a callable function anymore\n        memoComponent = memo(forwardRef(wrappedComponent));\n    }\n    else {\n        memoComponent = memo(wrappedComponent);\n    }\n    copyStaticProperties(baseComponent, memoComponent);\n    memoComponent.displayName = baseComponentName;\n    return memoComponent;\n}\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nvar hoistBlackList = {\n    $$typeof: true,\n    render: true,\n    compare: true,\n    type: true\n};\nfunction copyStaticProperties(base, target) {\n    Object.keys(base).forEach(function (key) {\n        if (!hoistBlackList[key]) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\n        }\n    });\n}\n","import React from 'react';\nimport { createUseStyles, useTheme, Theme } from '../theme';\nimport { useParams } from 'react-router-dom';\nimport { useAppState } from '../state/weather-state';\nimport { observer } from 'mobx-react-lite';\nimport Scaffold from '../containers/Scaffold';\n\nconst useStyles = createUseStyles<Theme>(theme => ({\n  root: {\n    backgroundColor: theme.colorPrimary,\n    color: theme.textPrimary,\n  },\n}));\n\nconst CityWeather: React.FC = observer(() => {\n  const theme = useTheme();\n  const classes = useStyles({theme});\n\n  const {country, region, name} = useParams<{country: string, region: string, name: string}>();\n  const state = useAppState();\n\n  const city = state.findCity(country, region, name);\n\n  React.useEffect(() => {\n    !city && state.fetchCity(name);\n  }, [city, name, state]);\n\n  const addToFavorite = () => {\n    city && state.addToFavorite(city);\n  }\n\n  const removeFromFavorite = () => {\n    if(city) {\n      state.removeFromFavorite(city);\n      state.addToTopCity(city);\n    }\n  }\n\n  const favorite = city?.isFavorite();\n\n  return (\n    <Scaffold>\n      <div className={classes.root}>\n        {city && <div>\n          City {city.name}\n          {city.currentWeather && <>Temp {city.currentWeather?.temp_c}</>}\n          {!city.currentWeather && <>:D</>}\n          {city.currentWeather && !favorite && <button onClick={addToFavorite}>add fav</button>}\n          {city.currentWeather && favorite && <button onClick={removeFromFavorite}>remove fav</button>}\n        </div>}\n        {!city && <span>...</span>}\n      </div>\n    </Scaffold>\n  );\n});\n\nexport default CityWeather;\n"],"sourceRoot":""}