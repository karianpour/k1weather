{"version":3,"sources":["../node_modules/mobx-react-lite/es/staticRendering.js","../node_modules/mobx-react-lite/es/printDebugValue.js","../node_modules/mobx-react-lite/es/reactionCleanupTracking.js","../node_modules/mobx-react-lite/es/useQueuedForceUpdate.js","../node_modules/mobx-react-lite/es/useObserver.js","../node_modules/mobx-react-lite/es/observer.js","pages/CityWeather.tsx"],"names":["globalIsUsingStaticRendering","isUsingStaticRendering","printDebugValue","v","getDependencyTree","reactionCleanupHandle","CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS","uncommittedReactionRefs","Set","ensureCleanupTimerRunning","undefined","setTimeout","cleanUncommittedReactions","now","Date","forEach","ref","tracking","current","cleanAt","reaction","dispose","delete","size","insideRender","forceUpdateQueue","EMPTY_OBJECT","observerComponentNameFor","baseComponentName","useObserver","fn","options","queuedForceUpdate","forceUpdate","push","useQueuedForceUpdate","useForceUpdate","reactionTrackingRef","React","useRef","newReaction_1","Reaction","trackingData_1","mounted","createTrackingData","add","useDebugValue","useEffect","reactionRef","Infinity","callback","result","queue_1","length","useLayoutEffect","x","useQueuedForceUpdateBlock","rendering","exception","track","e","__assign","Object","assign","t","s","i","n","arguments","p","prototype","hasOwnProperty","call","apply","this","observer","baseComponent","memoComponent","base","target","realOptions","forwardRef","displayName","name","wrappedComponent","props","memo","keys","key","hoistBlackList","defineProperty","getOwnPropertyDescriptor","$$typeof","render","compare","type","useStyles","createUseStyles","theme","root","backgroundColor","colorPrimary","color","textPrimary","CityWeather","useTheme","classes","useParams","state","useAppState","city","findCity","fetchCity","favorite","isFavorite","className","currentWeather","temperature","onClick","addToFavorite","removeFromFavorite"],"mappings":"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","file":"static/js/4.4ee9ffa0.chunk.js","sourcesContent":["var globalIsUsingStaticRendering = false;\nexport function useStaticRendering(enable) {\n    globalIsUsingStaticRendering = enable;\n}\nexport function isUsingStaticRendering() {\n    return globalIsUsingStaticRendering;\n}\n","import { getDependencyTree } from \"mobx\";\nexport function printDebugValue(v) {\n    return getDependencyTree(v);\n}\n","export function createTrackingData(reaction) {\n    var trackingData = {\n        cleanAt: Date.now() + CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS,\n        reaction: reaction\n    };\n    return trackingData;\n}\n/**\n * The minimum time before we'll clean up a Reaction created in a render\n * for a component that hasn't managed to run its effects. This needs to\n * be big enough to ensure that a component won't turn up and have its\n * effects run without being re-rendered.\n */\nexport var CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS = 10000;\n/**\n * The frequency with which we'll check for leaked reactions.\n */\nexport var CLEANUP_TIMER_LOOP_MILLIS = 10000;\n/**\n * Reactions created by components that have yet to be fully mounted.\n */\nvar uncommittedReactionRefs = new Set();\n/**\n * Latest 'uncommitted reactions' cleanup timer handle.\n */\nvar reactionCleanupHandle;\nfunction ensureCleanupTimerRunning() {\n    if (reactionCleanupHandle === undefined) {\n        reactionCleanupHandle = setTimeout(cleanUncommittedReactions, CLEANUP_TIMER_LOOP_MILLIS);\n    }\n}\nexport function scheduleCleanupOfReactionIfLeaked(ref) {\n    uncommittedReactionRefs.add(ref);\n    ensureCleanupTimerRunning();\n}\nexport function recordReactionAsCommitted(reactionRef) {\n    uncommittedReactionRefs.delete(reactionRef);\n}\n/**\n * Run by the cleanup timer to dispose any outstanding reactions\n */\nfunction cleanUncommittedReactions() {\n    reactionCleanupHandle = undefined;\n    // Loop through all the candidate leaked reactions; those older\n    // than CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS get tidied.\n    var now = Date.now();\n    uncommittedReactionRefs.forEach(function (ref) {\n        var tracking = ref.current;\n        if (tracking) {\n            if (now >= tracking.cleanAt) {\n                // It's time to tidy up this leaked reaction.\n                tracking.reaction.dispose();\n                ref.current = null;\n                uncommittedReactionRefs.delete(ref);\n            }\n        }\n    });\n    if (uncommittedReactionRefs.size > 0) {\n        // We've just finished a round of cleanups but there are still\n        // some leak candidates outstanding.\n        ensureCleanupTimerRunning();\n    }\n}\n/* istanbul ignore next */\n/**\n * Only to be used by test functions; do not export outside of mobx-react-lite\n */\nexport function forceCleanupTimerToRunNowForTests() {\n    // This allows us to control the execution of the cleanup timer\n    // to force it to run at awkward times in unit tests.\n    if (reactionCleanupHandle) {\n        clearTimeout(reactionCleanupHandle);\n        cleanUncommittedReactions();\n    }\n}\n/* istanbul ignore next */\nexport function resetCleanupScheduleForTests() {\n    if (reactionCleanupHandle) {\n        clearTimeout(reactionCleanupHandle);\n        reactionCleanupHandle = undefined;\n    }\n    uncommittedReactionRefs.clear();\n}\n","import React from \"react\";\nvar insideRender = false;\nvar forceUpdateQueue = [];\nexport function useQueuedForceUpdate(forceUpdate) {\n    return function () {\n        if (insideRender) {\n            forceUpdateQueue.push(forceUpdate);\n        }\n        else {\n            forceUpdate();\n        }\n    };\n}\nexport function useQueuedForceUpdateBlock(callback) {\n    // start intercepting force-update calls\n    insideRender = true;\n    forceUpdateQueue = [];\n    try {\n        var result = callback();\n        // stop intercepting force-update\n        insideRender = false;\n        // store queue or nothing if it was empty to execute useLayoutEffect only when necessary\n        var queue_1 = forceUpdateQueue.length > 0 ? forceUpdateQueue : undefined;\n        // run force-update queue in useLayoutEffect\n        React.useLayoutEffect(function () {\n            if (queue_1) {\n                queue_1.forEach(function (x) { return x(); });\n            }\n        }, [queue_1]);\n        return result;\n    }\n    finally {\n        insideRender = false;\n    }\n}\n","import { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./printDebugValue\";\nimport { createTrackingData, recordReactionAsCommitted, scheduleCleanupOfReactionIfLeaked } from \"./reactionCleanupTracking\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { useForceUpdate } from \"./utils\";\nimport { useQueuedForceUpdate, useQueuedForceUpdateBlock } from \"./useQueuedForceUpdate\";\nvar EMPTY_OBJECT = {};\nfunction observerComponentNameFor(baseComponentName) {\n    return \"observer\" + baseComponentName;\n}\nexport function useObserver(fn, baseComponentName, options) {\n    if (baseComponentName === void 0) { baseComponentName = \"observed\"; }\n    if (options === void 0) { options = EMPTY_OBJECT; }\n    if (isUsingStaticRendering()) {\n        return fn();\n    }\n    var wantedForceUpdateHook = options.useForceUpdate || useForceUpdate;\n    var forceUpdate = wantedForceUpdateHook();\n    var queuedForceUpdate = useQueuedForceUpdate(forceUpdate);\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    var reactionTrackingRef = React.useRef(null);\n    if (!reactionTrackingRef.current) {\n        // First render for this component (or first time since a previous\n        // reaction from an abandoned render was disposed).\n        var newReaction_1 = new Reaction(observerComponentNameFor(baseComponentName), function () {\n            // Observable has changed, meaning we want to re-render\n            // BUT if we're a component that hasn't yet got to the useEffect()\n            // stage, we might be a component that _started_ to render, but\n            // got dropped, and we don't want to make state changes then.\n            // (It triggers warnings in StrictMode, for a start.)\n            if (trackingData_1.mounted) {\n                // We have reached useEffect(), so we're mounted, and can trigger an update\n                queuedForceUpdate();\n            }\n            else {\n                // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n                // when (and if) useEffect() arrives.  The easiest way to do that is just to\n                // drop our current reaction and allow useEffect() to recreate it.\n                newReaction_1.dispose();\n                reactionTrackingRef.current = null;\n            }\n        });\n        var trackingData_1 = createTrackingData(newReaction_1);\n        reactionTrackingRef.current = trackingData_1;\n        scheduleCleanupOfReactionIfLeaked(reactionTrackingRef);\n    }\n    var reaction = reactionTrackingRef.current.reaction;\n    React.useDebugValue(reaction, printDebugValue);\n    React.useEffect(function () {\n        // Called on first mount only\n        recordReactionAsCommitted(reactionTrackingRef);\n        if (reactionTrackingRef.current) {\n            // Great. We've already got our reaction from our render;\n            // all we need to do is to record that it's now mounted,\n            // to allow future observable changes to trigger re-renders\n            reactionTrackingRef.current.mounted = true;\n        }\n        else {\n            // The reaction we set up in our render has been disposed.\n            // This is either due to bad timings of renderings, e.g. our\n            // component was paused for a _very_ long time, and our\n            // reaction got cleaned up, or we got a observable change\n            // between render and useEffect\n            // Re-create the reaction\n            reactionTrackingRef.current = {\n                reaction: new Reaction(observerComponentNameFor(baseComponentName), function () {\n                    // We've definitely already been mounted at this point\n                    queuedForceUpdate();\n                }),\n                cleanAt: Infinity\n            };\n            queuedForceUpdate();\n        }\n        return function () {\n            reactionTrackingRef.current.reaction.dispose();\n            reactionTrackingRef.current = null;\n        };\n    }, []);\n    // delay all force-update calls after rendering of this component\n    return useQueuedForceUpdateBlock(function () {\n        // render the original component, but have the\n        // reaction track the observables, so that rendering\n        // can be invalidated (see above) once a dependency changes\n        var rendering;\n        var exception;\n        reaction.track(function () {\n            try {\n                rendering = fn();\n            }\n            catch (e) {\n                exception = e;\n            }\n        });\n        if (exception) {\n            throw exception; // re-throw any exceptions caught during rendering\n        }\n        return rendering;\n    });\n}\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { forwardRef, memo } from \"react\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { useObserver } from \"./useObserver\";\n// n.b. base case is not used for actual typings or exported in the typing files\nexport function observer(baseComponent, options) {\n    // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\n    if (isUsingStaticRendering()) {\n        return baseComponent;\n    }\n    var realOptions = __assign({ forwardRef: false }, options);\n    var baseComponentName = baseComponent.displayName || baseComponent.name;\n    var wrappedComponent = function (props, ref) {\n        return useObserver(function () { return baseComponent(props, ref); }, baseComponentName);\n    };\n    wrappedComponent.displayName = baseComponentName;\n    // memo; we are not interested in deep updates\n    // in props; we assume that if deep objects are changed,\n    // this is in observables, which would have been tracked anyway\n    var memoComponent;\n    if (realOptions.forwardRef) {\n        // we have to use forwardRef here because:\n        // 1. it cannot go before memo, only after it\n        // 2. forwardRef converts the function into an actual component, so we can't let the baseComponent do it\n        //    since it wouldn't be a callable function anymore\n        memoComponent = memo(forwardRef(wrappedComponent));\n    }\n    else {\n        memoComponent = memo(wrappedComponent);\n    }\n    copyStaticProperties(baseComponent, memoComponent);\n    memoComponent.displayName = baseComponentName;\n    return memoComponent;\n}\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nvar hoistBlackList = {\n    $$typeof: true,\n    render: true,\n    compare: true,\n    type: true\n};\nfunction copyStaticProperties(base, target) {\n    Object.keys(base).forEach(function (key) {\n        if (!hoistBlackList[key]) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\n        }\n    });\n}\n","import React from 'react';\nimport { createUseStyles, useTheme, Theme } from '../theme';\nimport { useParams } from 'react-router-dom';\nimport { useAppState } from '../state/weather-state';\nimport { observer } from 'mobx-react-lite';\n\nconst useStyles = createUseStyles<Theme>(theme => ({\n  root: {\n    backgroundColor: theme.colorPrimary,\n    color: theme.textPrimary,\n  },\n}));\n\nconst CityWeather: React.FC = observer(() => {\n  const theme = useTheme();\n  const classes = useStyles({theme});\n\n  const {name} = useParams<{name: string}>();\n  const state = useAppState();\n\n  const city = state.findCity(name);\n\n  React.useEffect(() => {\n    !city && state.fetchCity(name);\n  }, [city, name, state]);\n\n  const addToFavorite = () => {\n    city && state.addToFavorite(city);\n  }\n\n  const removeFromFavorite = () => {\n    city && state.removeFromFavorite(city);\n  }\n\n  const favorite = city?.isFavorite();\n\n  return (\n    <div className={classes.root}>\n      {city && <div>\n        City {city.name}\n        {city.currentWeather && <>Temp {city.currentWeather?.temperature}</>}\n        {!city.currentWeather && <>:D</>}\n        {city.currentWeather && !favorite && <button onClick={addToFavorite}>add fav</button>}\n        {city.currentWeather && favorite && <button onClick={removeFromFavorite}>remove fav</button>}\n      </div>}\n      {!city && <span>...</span>}\n    </div>\n  );\n});\n\nexport default CityWeather;\n"],"sourceRoot":""}